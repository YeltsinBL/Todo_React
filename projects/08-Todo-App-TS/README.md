# React + TypeScript + Vite

Aplicación Todo-App con TypeScript

## Objetivos

- ✅ Inicializar proyecto con Vite
- ✅ Añadir linter para TypeScript + React
- ✅ Añadir estilos del TodoMVC
- ✅ Listar todos los TODOs
- ✅ Poder borrar un TODO
- ✅ Marcar TODO como completado
- ✅ Añadir forma de filtrar TODOs (Footer)
- ✅ Mostrar número de TODOs pendientes (Footer)
- ✅ Añadir forma de borrar todos los TODOs completados
- ✅ Crear Header con input (Header)
- ✅ Crear un TODO (Header)
- [ ] Poder editar el texto de un TODO (Doble click)
- [ ] Añadir animaciones con AutoAnimate
- [ ] Pasar a Reducer
- [ ] Sincronizar con el backend

## Procesos

- Añadir linter para TypeScript + React
  - Se utilizó el siguiente comando en la terminal: `npm init @eslint/config`
  - Luego se configuró las especificaciones que utilice JavaScript (ESM), React, TypeScript, Browser, Guide, Standard, JavaScript y en mi caso, tuve que instalar manualmente las dependencias que se indicará en la terminar.
    - En una de las dependencias me dio error por las versiones y tuve que utilizar `--legacy-peer-deps` al final del comando.
  - En el proyecto
    - En el archivo '.eslintrc.cjs': Agregar en el "parserOptions": {
        "project":'./tsconfig.json'
    } para que reconozca las configuraciones de ese archivo.
    - En el App.tsx aparecerán los errores para las correcciones, solo agregar 'React' en la importación de react.
- Añadir estilos del TodoMVC
  - Instalamos una dependencia para utilizar los css que tiene: `npm i todomvc-app-css -E --legacy-peer-deps`
    - Uso el legacy porque tengo conflicto con las versiones.
  - Agregamos el import del css en el 'main.tsx'
  - Eliminamos el App.css y el código css de index.css.
  - Crear el fichero 'type.d.ts'.
    - Exportamos una interfaz que contendrá sus propiedad y el tipo de dato.
    - Exportamos un tipo que sera una lista de la interfaz anterior.
  - Crear el fichero Todo.tsx que contendrá el componente Todo para listar los datos.
    - Exportamos la constante Todo que es del tipo React.FC, el cual lo tipamos mediante una interfaz Prop que será una lista de objetos. Esta lista lo obtenemos del 'type.d.ts'.
    - Mapeamos este parámetro para ir listándolo con datos de prueba.
  - En el App.tsx
    - Simulamos unos datos de acuerdo a la lista del 'type.d.ts'.
    - Convertimos la función App en una constante que será del tipo 'JSX.Element'
    - Utilizamos el componente Todos y le pasamos los datos simulados.
- Listar todos los TODOs
  - Creamos el Todo.tsx que será el componente de cada fila de la lista.
    - Este recibe el id, title y completed como props, porque son los valores que tiene la lista de objetos.
  - Utilizamos el componente 'Todo' en el Todos.tsx
    - Va dentro del mapeo del listado, envuelto por un 'li' pasándole las props requeridas.
  - Agregamos los className a los componentes para aplicar el css de la dependencia instalada.
- Borrar un TODO
  - Usamos UtilityType para obtenerlos tipos de la Interfaz del Todo
  - En el App.tsx
    - Creamos una función usando una constante que recibe un Id como parámetro para eliminar el Todo de la lista.
    - Esta función se pasará por todos los componentes hasta llegar al click del botón de eliminar.
  - En el Todos.tsx
    - Agregamos un nuevo parámetro en el interfaz del Prop para que acepte la función como parámetro.
    - Pasamos el parámetro en el componente Todo.
  - En el Todo.tsx
    - Creamos una interfaz Prop que extienda de la otra interfaz del Todo para agregar otra propiedad que acepte la función como parámetro.
    - Pasamos la función al click del botón.
- Marcar TODO como completado
  - Creamos una función 'handleCompleted' que recibe los parámetros 'id y completed' para actualizar los datos de la lista.
    - Indicamos el tipo de dato de los parámetros utilizando el Pick para sacar el tipo de la misma lista.
    - Esta función se pasará por todos los componentes hasta llegar al componente que lo utilizará.
  - Agregamos la nueva propiedad con sus parámetro en las interfaces del Todos.tsx y Todo.tsx para que el componente de cada uno los acepte.
  - En el Todo.tsx, que es en donde se usará la función
    - Se crea otra función 'handleCompletedTodoCheck' para pasarle los valores necesarios e indicar de que tipo de elemento pertenece este evento de cambio.
    - Se utiliza la nueva función 'handleCompletedTodoCheck' en el evento change del elemento input.
- Filtrar TODOs
  - Se creó un fichero 'consts.ts' que contiene las opciones del filtro y las acciones a cada opción.
  - En el fichero 'types.d.ts', creamos una constante que tendrá el valor de las opciones del filtro.
    - Primero obtenemos una 'key' de las opciones y luego obtenemos el valor del cual pertenece la key.
  - Creamos el fichero 'Filters.tsx'
    - Contiene el componente con todas las opciones del filtro.
    - Se crea una interfaz 'Props' que contiene los valores que recibirá el componente.
      - filterSelected: El valor del filtro seleccionado.
      - onFilterChange: Función que recibe el key de la opción del filtro seleccionado para mostrar sus respectivos datos.
    - En el componente, convertimos los datos de las opciones del filtro en un array para mapearlos y utilizamos sus datos junto con los parámetros para mostrar las opciones con su funcionalidad.
  - Creamos el fichero 'Footer.tsx'
    - Se crea una interfaz 'Props' que contiene los valores que recibirá el componente.
    - Este componente utiliza el componente del Filters y pasa sus valores necesarios.
  - En el App.tsx
    - Se crea un useState el cual almacenará el valor del filtro seleccionado.
    - Creamos la funciones handleFilterChange que recibe como parámetro la key del filtro seleccionado para actualizar el useState del filtro seleccionado.
    - Creamos un nuevo array cuyos datos serán del filtro del array actual.
    - Reemplazamos el envío de datos del array actual por el nuevo array filtrado en el componente Todos.
    - Utilizamos el componente Footer y le pasamos sus valores necesarios, el valor del useState del filtro seleccionado y la función para actualizar el useState del filtro seleccionado.
- Mostrar número de TODOs pendientes
  - En el Footer.tsx
    - Agregamos un nuevo parámetro en la interfaz Prop, 'activeCount'.
    - Utilizamos este parámetro dentro del componente Footer en un span.
  -En el App.tsx
    - Creamos una nueva constante que será el total de los datos activos.
    - Pasamos esta constante al componente Footer.
- Borrar todos los TODOs completados
  - En el Footer.tsx
    - Agregamos nuevas propiedades a la interfaz Prop, completedCount y onClearCompleted, para que sirvan como parámetros en el componente.
    - Utilizamos el completedCount para mostrar el botón de borrar.
    - Pasamos el onClearCompleted al evento click del botón borrar.
  - En el App.tsx
    - Creamos una función para actualizar el useState de la lista del TODO filtrando solo por los que no están completados.
    - Creamos una constante que indicará la cantidad de TODO completados.
    - Pasamos al componente Footer los nuevos datos requeridos, la función y constante.
- Crear Header con input
  - Creamos el fichero CreateTodo.tsx
    - Contiene el componente CreateTodo
    - Este componente usa un useState para actualizar el ingreso de datos, este cambio se hace en el evento OnChange del input.
    - El input esta dentro de un form, que se usará para agregar los datos ingresados al TODO.
  - Creamos el Header.tsx
    - Contiene el componente Header
    - Utiliza el componente CreateTodo.
  - En el App.tsx, usamos el componente Header para mostrarlo.
- Crear un TODO
  - En el CreateTodo.tsx
    - Agregamos en la interfaz Prop la propiedad saveTodo que servirá como parámetro del componente para guardar el nuevo dato al TODO.
    - Creamos la función handleSubmit, indicando que el event es un HTMLFormElement, usamos el parámetro saveTodo pasándole el valor agregado en el input y actualizamos el useState reseteando el valor.
    - Usamos la función handleSubmit en el evento onSubmit del Form.
  - En el Header.tsx
    - Agregamos en la interfaz Prop la propiedad onAddTodo para pasarlo al componente CreateTodo.
  - En App.tsx
    - Creamos la función handleAddTodo que recibe como parámetro el texto agregado en el input,
    - Dentro de la función handleAddTodo creamos un nuevo TODO, el cual lo unimos con el TODO principal en una nueva constante y lo pasamos actualizando el useState del TODOS.
    - Pasamos la función al componente Header.
