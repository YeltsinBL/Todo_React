# React + TypeScript + Vite

Aplicación Todo-App con TypeScript

## Objetivos

- ✅ Inicializar proyecto con Vite
- ✅ Añadir linter para TypeScript + React
- ✅ Añadir estilos del TodoMVC
- ✅ Listar todos los TODOs
- ✅ Poder borrar un TODO
- ✅ Marcar TODO como completado
- ✅ Añadir forma de filtrar TODOs (Footer)
- ✅ Mostrar número de TODOs pendientes (Footer)
- ✅ Añadir forma de borrar todos los TODOs completados
- ✅ Crear Header con input (Header)
- ✅ Crear un TODO (Header)
- ✅ Poder editar el texto de un TODO (Doble click)
- ✅ Añadir animaciones con AutoAnimate
- ✅ Pasar a CustomHook
- ✅ Añadir el filtro seleccionado como parámetro en la url.
- ✅ Pasar a Reducer
- [ ] Sincronizar con el backend

## Procesos

- Añadir linter para TypeScript + React
  - Se utilizó el siguiente comando en la terminal: `npm init @eslint/config`
  - Luego se configuró las especificaciones que utilice JavaScript (ESM), React, TypeScript, Browser, Guide, Standard, JavaScript y en mi caso, tuve que instalar manualmente las dependencias que se indicará en la terminar.
    - En una de las dependencias me dio error por las versiones y tuve que utilizar `--legacy-peer-deps` al final del comando.
  - En el proyecto
    - En el archivo '.eslintrc.cjs': Agregar en el "parserOptions": {
        "project":'./tsconfig.json'
    } para que reconozca las configuraciones de ese archivo.
    - En el App.tsx aparecerán los errores para las correcciones, solo agregar 'React' en la importación de react.
- Añadir estilos del TodoMVC
  - Instalamos una dependencia para utilizar los css que tiene: `npm i todomvc-app-css -E --legacy-peer-deps`
    - Uso el legacy porque tengo conflicto con las versiones.
  - Agregamos el import del css en el 'main.tsx'
  - Eliminamos el App.css y el código css de index.css.
  - Crear el fichero 'type.d.ts'.
    - Exportamos una interfaz que contendrá sus propiedad y el tipo de dato.
    - Exportamos un tipo que sera una lista de la interfaz anterior.
  - Crear el fichero Todo.tsx que contendrá el componente Todo para listar los datos.
    - Exportamos la constante Todo que es del tipo React.FC, el cual lo tipamos mediante una interfaz Prop que será una lista de objetos. Esta lista lo obtenemos del 'type.d.ts'.
    - Mapeamos este parámetro para ir listándolo con datos de prueba.
  - En el App.tsx
    - Simulamos unos datos de acuerdo a la lista del 'type.d.ts'.
    - Convertimos la función App en una constante que será del tipo 'JSX.Element'
    - Utilizamos el componente Todos y le pasamos los datos simulados.
- Listar todos los TODOs
  - Creamos el Todo.tsx que será el componente de cada fila de la lista.
    - Este recibe el id, title y completed como props, porque son los valores que tiene la lista de objetos.
  - Utilizamos el componente 'Todo' en el Todos.tsx
    - Va dentro del mapeo del listado, envuelto por un 'li' pasándole las props requeridas.
  - Agregamos los className a los componentes para aplicar el css de la dependencia instalada.
- Borrar un TODO
  - Usamos UtilityType para obtenerlos tipos de la Interfaz del Todo
  - En el App.tsx
    - Creamos una función usando una constante que recibe un Id como parámetro para eliminar el Todo de la lista.
    - Esta función se pasará por todos los componentes hasta llegar al click del botón de eliminar.
  - En el Todos.tsx
    - Agregamos un nuevo parámetro en el interfaz del Prop para que acepte la función como parámetro.
    - Pasamos el parámetro en el componente Todo.
  - En el Todo.tsx
    - Creamos una interfaz Prop que extienda de la otra interfaz del Todo para agregar otra propiedad que acepte la función como parámetro.
    - Pasamos la función al click del botón.
- Marcar TODO como completado
  - Creamos una función 'handleCompleted' que recibe los parámetros 'id y completed' para actualizar los datos de la lista.
    - Indicamos el tipo de dato de los parámetros utilizando el Pick para sacar el tipo de la misma lista.
    - Esta función se pasará por todos los componentes hasta llegar al componente que lo utilizará.
  - Agregamos la nueva propiedad con sus parámetro en las interfaces del Todos.tsx y Todo.tsx para que el componente de cada uno los acepte.
  - En el Todo.tsx, que es en donde se usará la función
    - Se crea otra función 'handleCompletedTodoCheck' para pasarle los valores necesarios e indicar de que tipo de elemento pertenece este evento de cambio.
    - Se utiliza la nueva función 'handleCompletedTodoCheck' en el evento change del elemento input.
- Filtrar TODOs
  - Se creó un fichero 'consts.ts' que contiene las opciones del filtro y las acciones a cada opción.
  - En el fichero 'types.d.ts', creamos una constante que tendrá el valor de las opciones del filtro.
    - Primero obtenemos una 'key' de las opciones y luego obtenemos el valor del cual pertenece la key.
  - Creamos el fichero 'Filters.tsx'
    - Contiene el componente con todas las opciones del filtro.
    - Se crea una interfaz 'Props' que contiene los valores que recibirá el componente.
      - filterSelected: El valor del filtro seleccionado.
      - onFilterChange: Función que recibe el key de la opción del filtro seleccionado para mostrar sus respectivos datos.
    - En el componente, convertimos los datos de las opciones del filtro en un array para mapearlos y utilizamos sus datos junto con los parámetros para mostrar las opciones con su funcionalidad.
  - Creamos el fichero 'Footer.tsx'
    - Se crea una interfaz 'Props' que contiene los valores que recibirá el componente.
    - Este componente utiliza el componente del Filters y pasa sus valores necesarios.
  - En el App.tsx
    - Se crea un useState el cual almacenará el valor del filtro seleccionado.
    - Creamos la funciones handleFilterChange que recibe como parámetro la key del filtro seleccionado para actualizar el useState del filtro seleccionado.
    - Creamos un nuevo array cuyos datos serán del filtro del array actual.
    - Reemplazamos el envío de datos del array actual por el nuevo array filtrado en el componente Todos.
    - Utilizamos el componente Footer y le pasamos sus valores necesarios, el valor del useState del filtro seleccionado y la función para actualizar el useState del filtro seleccionado.
- Mostrar número de TODOs pendientes
  - En el Footer.tsx
    - Agregamos un nuevo parámetro en la interfaz Prop, 'activeCount'.
    - Utilizamos este parámetro dentro del componente Footer en un span.
  -En el App.tsx
    - Creamos una nueva constante que será el total de los datos activos.
    - Pasamos esta constante al componente Footer.
- Borrar todos los TODOs completados
  - En el Footer.tsx
    - Agregamos nuevas propiedades a la interfaz Prop, completedCount y onClearCompleted, para que sirvan como parámetros en el componente.
    - Utilizamos el completedCount para mostrar el botón de borrar.
    - Pasamos el onClearCompleted al evento click del botón borrar.
  - En el App.tsx
    - Creamos una función para actualizar el useState de la lista del TODO filtrando solo por los que no están completados.
    - Creamos una constante que indicará la cantidad de TODO completados.
    - Pasamos al componente Footer los nuevos datos requeridos, la función y constante.
- Crear Header con input
  - Creamos el fichero CreateTodo.tsx
    - Contiene el componente CreateTodo
    - Este componente usa un useState para actualizar el ingreso de datos, este cambio se hace en el evento OnChange del input.
    - El input esta dentro de un form, que se usará para agregar los datos ingresados al TODO.
  - Creamos el Header.tsx
    - Contiene el componente Header
    - Utiliza el componente CreateTodo.
  - En el App.tsx, usamos el componente Header para mostrarlo.
- Crear un TODO
  - En el CreateTodo.tsx
    - Agregamos en la interfaz Prop la propiedad saveTodo que servirá como parámetro del componente para guardar el nuevo dato al TODO.
    - Creamos la función handleSubmit, indicando que el event es un HTMLFormElement, usamos el parámetro saveTodo pasándole el valor agregado en el input y actualizamos el useState reseteando el valor.
    - Usamos la función handleSubmit en el evento onSubmit del Form.
  - En el Header.tsx
    - Agregamos en la interfaz Prop la propiedad onAddTodo para pasarlo al componente CreateTodo.
  - En App.tsx
    - Creamos la función handleAddTodo que recibe como parámetro el texto agregado en el input,
    - Dentro de la función handleAddTodo creamos un nuevo TODO, el cual lo unimos con el TODO principal en una nueva constante y lo pasamos actualizando el useState del TODOS.
    - Pasamos la función al componente Header.
- Editar el texto de un TODO
  - En Todo.tsx
    - Utilizamos el UseEffect, UseState y UseRef
    - Agregamos nuevas propiedades a ls interfaz Prop
      - UpdateTodo: recibe el id y texto de la fila que se hizo doble click.
      - isEditing: verificar si se hizo doble click la fila para poner el cursor en el input.
      - setIdEditing: recibe como parámetro el nuevo texto para actualizar el valor de la fila.
    - Creamos un UseState al title.
    - Creamos un UseRef que sea del tipo HTMLInputElement.
    - Creamos la función handleKeyDown que sea del tipo HTMLInputElement para hacer la lógica del doble click.
    - Hacemos un UseEffect al isEditing para poner el cursor en el input.
    - Creamos el input usando sus propiedades necesarias para editar el valor.
  - En el Todos.tsx
    - Usamos el useState
    - Agregamos una propiedad a la interfaz Prop
      - OnUpdateTodo: recibe el id y titulo de la fila a actualizar.
    - Creamos un useState vacío.
    - Actualizamos el className de la lista (li) para agregar el modo edición (editing).
    - Usamos la propiedad del doble click para actualizar el valor del useState.
    - Pasamos los nuevos valores necesarios al componente Todo.
  - En el App.tsx
    - Creamos la función handleUpdateTodo
      - Recibe como parámetro un ide y titulo.
      - Recorremos la lista del Todos para verificar si el id existe y actualizar su valor.
      - Actualizamos el UseState de la lista del Todos.
    - Pasamos la función en la nueva propiedad del Todos.
- Animaciones con AutoAnimate
  - Instalamos la dependencia `npm install @formkit/auto-animate -E`
    - En mi caso, como tengo conflicto por versiones, agrego esto al final del comando: `--legacy-peer-deps`
  - Importamos el hook de la dependencia: 'useAutoAnimate' indicando en la importación que se esta usando React.
  - Creamos una constante del useAutoAnimate.
  - Usamos la constante en la referencia del ul.
- Pasar a CustomHook
  - Se creó un nuevo fichero UseTodos.ts.
  - Se movió todos los hooks de App.tsx a una función dentro del UseTodos.ts.
- Añadir el filtro seleccionado como parámetro en la url.
  - En useTodos.ts
    - En la función handleFilterChange: Se creó el parámetro filter y se agregó al path de la url.
- Pasar a Reducer
  - Se creó el fichero UseTodosReducer.ts
    - Se creó un tipo Action que contiene
      - Type: identifica la función
      - Payload: los parámetros que utilizará las funciones.
    - Se creo una interfaz State, con las propiedades
      - Sync: indicará True si hay cambios en la lista.
      - Todos: lista del TODO.
      - FilterSelected: valor del filtro.
    - Se creó una constante initialState con sus valores por defecto porque se cargará al iniciar la aplicación, sus propiedades
      - Sync: False
      - Todos: vacío
      - FilterSelected: dependiendo de la URL si tiene Query param mostrará la lista del filtro seleccionado.
    - Se creó una función reducer que recibe como parámetro la interfaz del State y el tipo Action.
      - Se realiza la lógica de acuerdo al tipo  de Acción.
    - Se creó un CustomHook UseTodos.
      - Se usó el UseReducer agregando la función reducer y la constante initialState.
      - Se crearon las funciones y lógica que se necesitará en el App.tsx.
  - Se modificaron los tipados de los parámetros en todos los componentes necesarios.
